# trainer.py (Version 7.0 - Final Automated Optimizer for Complex Model)

import json
import copy
import sys
import random
from model_template import calculate_reimbursement

def evaluate_mae(params, test_cases):
    total_error = 0
    if not test_cases: return float('inf')

    for case in test_cases:
        inputs = case['input']
        expected = case['expected_output']
        prediction = calculate_reimbursement(
            inputs['trip_duration_days'],
            inputs['miles_traveled'],
            inputs['total_receipts_amount'],
            params
        )
        total_error += abs(prediction - expected)

    return total_error / len(test_cases)

def generate_final_script(params, model_template_path='model_template.py', output_path='solution.py'):
    with open(model_template_path, 'r') as f:
        model_code = f.read()

    # Create the standalone execution block with the optimized parameters
    main_block = f"""
if __name__ == "__main__":
    # --- OPTIMIZED PARAMETERS (Generated by trainer.py) ---
    params = {json.dumps(params, indent=4)}

    if len(sys.argv) != 4:
        print("Usage: python solution.py <days> <miles> <receipts>")
        sys.exit(1)
    try:
        duration = int(sys.argv[1])
        miles = float(sys.argv[2])
        receipts = float(sys.argv[3])
        # Pass the params dict to the main function
        result = calculate_reimbursement(duration, miles, receipts, params)
        print(result)
    except Exception:
        print(0.0)
        sys.exit(0)
"""
    # Combine the original model logic with the new main block
    final_code = model_code.split('if __name__ == "__main__":')[0] + main_block

    with open(output_path, 'w') as f:
        f.write(final_code)
    print(f"\n‚úÖ Generated final '{output_path}' with optimized parameters.")

if __name__ == "__main__":
    current_params = {
        # Path 1: 1-day, high spend
        'p1_spend_threshold': 500.0, 'p1_super_ultra_miles_threshold': 1000.0, 'p1_ultra_miles_threshold': 600.0,
        'p1_per_diem_a': 100.0, 'p1_mileage_rate_a': 0.30, 'p1_receipt_rate_a': 0.50,
        'p1_per_diem_b': 100.0, 'p1_mileage_rate_b': 0.45, 'p1_receipt_rate_b': 0.60,
        'p1_per_diem_c': 150.0, 'p1_mileage_rate_c': 0.20, 'p1_receipt_cap_c': 100.0, 'p1_receipt_rate_c': 0.40,
        # Path 2: 2-4 day, high spend, low activity
        'p2_spend_threshold': 250.0, 'p2_miles_per_day_threshold': 20.0, 'p2_daily_receipt_cap': 100.0,
        'p2_per_diem': 150.0, 'p2_mileage_rate': 0.20, 'p2_receipt_rate': 0.40,
        # Path 3: 2-7 day, high spend (but not punitive)
        'p3_spend_threshold': 200.0, 'p3_per_diem_rate': 85.0, 'p3_mileage_rate': 0.48, 'p3_receipt_rate': 0.55,
        # Path 4: Ultra-frugal long trips
        'p4_spend_threshold': 75.0, 'p4_miles_per_day_threshold': 40.0, 'p4_per_diem_flat': 300.0,
        'p4_mileage_rate': 0.25, 'p4_receipt_rate': 0.50,
        # Path 5: "Vacation Penalty" long trips
        'p5_spend_threshold': 90.0, 'p5_daily_receipt_cap': 100.0, 'p5_per_diem_rate': 110.0,
        'p5_mileage_rate': 0.50, 'p5_receipt_rate': 0.47,
        # Default Path
        'def_per_diem_rate': 100.0, 'def_mileage_rate_t1': 0.58, 'def_mileage_rate_t2': 0.48, 'def_mileage_rate_t3': 0.38,
        'def_mileage_tier1_cutoff': 100.0, 'def_mileage_tier2_cutoff': 500.0, 'def_small_receipt_threshold': 25.0,
        'def_small_receipt_penalty': -25.0, 'def_receipt_rate': 0.80,
        # Global Bonuses
        'p_all_bonus_5_day': 50.0, 'p_all_eff_bonus_min': 150.0, 'p_all_eff_bonus_max': 250.0,
        'p_all_eff_bonus_amount': 35.0, 'p_all_rounding_bug_bonus': 5.51
    }

    step_sizes = {key: abs(val * 0.1) if val != 0 else 0.1 for key, val in current_params.items()}
    # Manually adjust a few key integer/sensitive steps
    for key in step_sizes:
        if 'threshold' in key or 'cutoff' in key:
            step_sizes[key] = max(1.0, step_sizes[key])

    STEP_DECAY_FACTOR, MAX_PATIENCE = 0.999, 20

    with open('public_cases.json', 'r') as f:
        test_cases = json.load(f)

    best_mae = evaluate_mae(current_params, test_cases)
    print(f"üöÄ Starting Automated Training with Complex Path Model...")
    print(f"Initial MAE: {best_mae:.4f}")

    iteration = 0
    patience_counter = 0
    while patience_counter < MAX_PATIENCE:
        iteration += 1
        improvement_found_in_iteration = False

        params_to_tweak = list(current_params.keys())
        random.shuffle(params_to_tweak)

        for param in params_to_tweak:
            best_neighbor_params = None
            mae_for_best_neighbor = best_mae

            for sign in [-1, 1]:
                neighbor_params = copy.deepcopy(current_params)
                step = step_sizes[param]
                neighbor_params[param] += sign * step

                if isinstance(current_params[param], int):
                    neighbor_params[param] = int(round(neighbor_params[param]))

                current_mae = evaluate_mae(neighbor_params, test_cases)
                if current_mae < mae_for_best_neighbor:
                    mae_for_best_neighbor = current_mae
                    best_neighbor_params = neighbor_params

            if best_neighbor_params:
                improvement = best_mae - mae_for_best_neighbor
                print(f"  [Iter {iteration}] Improvement on '{param}': {best_mae:.4f} -> {mae_for_best_neighbor:.4f} (Œî {-improvement:.4f})")
                best_mae = mae_for_best_neighbor
                current_params = best_neighbor_params
                improvement_found_in_iteration = True

        if improvement_found_in_iteration:
            print(f"--- Iteration {iteration} END | Best MAE: {best_mae:.4f} | Decaying Step Sizes... ---")
            for key in step_sizes: step_sizes[key] *= STEP_DECAY_FACTOR
            patience_counter = 0
        else:
            patience_counter += 1
            print(f"--- Iteration {iteration} END | No improvement. Patience: {patience_counter}/{MAX_PATIENCE} ---")

    print(f"\nüèÅ CONVERGENCE REACHED. Final Best MAE: {best_mae:.4f}")
    generate_final_script(current_params)